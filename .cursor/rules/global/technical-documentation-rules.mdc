---
description: technical documentation including architecture documentation, API specifications, and implementation details
globs: 
alwaysApply: false
---
# Technical Documentation Rules
Version: 1.0.0
Last Updated: 2025-03-23

## Purpose and Scope
This rule defines standards for technical documentation, including architecture documentation, API specifications, and implementation details. These standards ensure clarity, accuracy, and completeness in technical documentation to facilitate effective development and maintenance.

## Parent Rules
@rule:global-documentation-standards
@rule:global-ai-interaction-standards

## Rule Specifications

### Rule T-1: Technical Documentation Structure
Technical documentation must be organized into the following categories:
1. Architecture & System Design
   - System architecture
   - Data architecture
   - Solution architecture
2. APIs & Integration
   - Internal APIs
   - External APIs
   - API standards
3. Infrastructure & Operations
   - Cloud infrastructure
   - Deployment configurations
   - Monitoring setup
4. Mobile & Client
   - Mobile architecture
   - Mobile APIs
   - Mobile development
5. Testing & Quality
   - Test plans
   - Test automation
   - Performance testing
6. Platform Services
   - Localization
   - Security
   - DevOps

### Rule T-2: Architecture Documentation Format
Architecture documentation must include:
1. System overview (high-level description)
2. Architecture principles (guiding principles)
3. Component diagram (visual representation)
4. Component descriptions (detailed descriptions)
5. Interaction patterns (how components interact)
6. Data flow diagrams (how data moves through the system)
7. Technology stack (technologies used)
8. Constraints and limitations
9. Cross-cutting concerns (security, performance, etc.)
10. Evolution strategy (how the architecture will evolve)

### Rule T-3: API Documentation Format
API documentation must include:
1. API overview (purpose and scope)
2. Authentication and authorization
3. Endpoint specifications:
   - URL/path
   - HTTP method
   - Request parameters
   - Request body schema
   - Response body schema
   - Status codes and error responses
   - Rate limiting information
4. Example requests and responses
5. SDK usage examples (if applicable)
6. Error handling guidelines
7. Versioning information
8. Deprecation policy

### Rule T-4: Data Architecture Documentation
Data architecture documentation must include:
1. Data models (entities and relationships)
2. Data flow diagrams (how data moves through the system)
3. Data storage solutions (databases, file storage, etc.)
4. Data access patterns (how data is accessed)
5. Data transformation processes (ETL, etc.)
6. Data security and privacy considerations
7. Data retention and archiving policies
8. Performance considerations
9. Schema evolution strategies

### Rule T-5: Infrastructure Documentation
Infrastructure documentation must include:
1. Infrastructure overview (high-level description)
2. Environment descriptions (dev, test, staging, production)
3. Network architecture
4. Compute resources (servers, containers, etc.)
5. Storage resources
6. Database configurations
7. Scaling strategies
8. Disaster recovery procedures
9. Monitoring and alerting setup
10. Infrastructure as code definitions

### Rule T-6: Implementation Documentation
Implementation documentation must include:
1. Code organization (directories, modules, etc.)
2. Design patterns used
3. Key algorithms and data structures
4. Third-party libraries and dependencies
5. Performance considerations
6. Security implementations
7. Error handling strategies
8. Logging and monitoring
9. Testing approaches
10. Cursor Implementation Directions

### Rule T-7: Diagrams and Visualizations
Technical diagrams must:
1. Use standard notation (UML, C4, etc.)
2. Include a key/legend
3. Be accompanied by textual descriptions
4. Be updated when the system changes
5. Include version information
6. Be stored in both source format (for editing) and rendered format (for viewing)
7. Have clear titles and labels
8. Use consistent styles across diagrams
9. Include appropriate level of detail for the audience
10. Be referenced from relevant documentation

### Rule T-8: Code Examples
Code examples must:
1. Be syntactically correct
2. Follow project coding standards
3. Include comments explaining key aspects
4. Be as concise as possible while still illustrating the concept
5. Be tested for accuracy
6. Include error handling where appropriate
7. Show best practices
8. Be properly formatted with syntax highlighting
9. Include language and version information
10. Be kept up to date with current implementations

### Rule T-9: Technical Decision Documentation
Technical decision documentation must:
1. Clearly state the problem being addressed
2. List options considered
3. Provide evaluation criteria
4. Include pros and cons for each option
5. Explain the decision made
6. Provide justification for the decision
7. Identify impacts and dependencies
8. Specify implementation timeline
9. Note any dissenting opinions
10. Include references to supporting research or precedents

### Rule T-10: Security Documentation
Security documentation must include:
1. Security model and principles
2. Authentication mechanisms
3. Authorization framework
4. Encryption standards
5. Data protection measures
6. Security controls implementation
7. Vulnerability management
8. Security testing procedures
9. Incident response procedures
10. Compliance requirements

### Rule T-11: Performance Documentation
Performance documentation must include:
1. Performance requirements and SLAs
2. Performance testing methodology
3. Benchmark results
4. Optimization strategies
5. Scalability considerations
6. Resource utilization metrics
7. Bottleneck analysis
8. Caching strategies
9. Load balancing approach
10. Monitoring and alerting thresholds

### Rule T-12: Cursor Implementation Directions
Cursor Implementation Directions in technical documentation must include:
1. File structure and organization
2. Component architecture
3. Implementation sequence
4. Key functions and methods
5. Data structures and interfaces
6. Error handling patterns
7. Testing strategy
8. Integration points
9. Performance considerations
10. References to similar implementations

## Application Examples

### Example 1: API Endpoint Documentation
```markdown
# User Authentication API

Last Updated: 2025-03-23

## Endpoint: Create Authentication Token

### Purpose
Creates an authentication token for a user based on their credentials.

### URL
`POST /api/v1/auth/token`

### Authentication
None (this endpoint is used to obtain authentication)

### Request Parameters
None

### Request Body
```json
{
  "email": "string",
  "password": "string",
  "remember_me": boolean (optional, default: false)
}
```

### Response Body
```json
{
  "token": "string",
  "expires_at": "ISO8601 timestamp",
  "user": {
    "id": "string",
    "email": "string",
    "name": "string",
    "role": "string"
  }
}
```

### Status Codes
- 200 OK: Authentication successful
- 400 Bad Request: Invalid request format
- 401 Unauthorized: Invalid credentials
- 422 Unprocessable Entity: Account locked or requires verification
- 500 Internal Server Error: Server error

### Error Responses
```json
{
  "error": "string",
  "message": "string",
  "details": {} (optional)
}
```

### Rate Limiting
This endpoint is limited to 5 requests per minute per IP address.

### Example Request
```curl
curl -X POST https://api.collectivemind.com/api/v1/auth/token \
  -H "Content-Type: application/json" \
  -d '{"email": "user@example.com", "password": "securepassword", "remember_me": true}'
```

### Example Response
```json
{
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expires_at": "2025-03-24T12:00:00Z",
  "user": {
    "id": "usr_123456789",
    "email": "user@example.com",
    "name": "John Doe",
    "role": "admin"
  }
}
```

### Notes
- Tokens are valid for 24 hours by default, or 30 days if remember_me is true
- Tokens must be included in the Authorization header as `Bearer {token}` for authenticated endpoints
- Invalid login attempts may trigger account lockout after 5 consecutive failures

### Related Documentation
- [Authentication Overview](mdc:../auth-overview.md)
- [User Management API](mdc:../users/user-management-api.md)
- [Token Security](mdc:../../security/token-security.md)
```

### Example 2: Architecture Component Documentation
```markdown
# Document Storage Service

Last Updated: 2025-03-23

## Purpose
The Document Storage Service is responsible for storing, retrieving, and managing document content and metadata within the CollectiveMind platform. It provides a scalable, secure, and high-performance storage solution for all document types.

## Architecture Principles
- Content is immutable; new versions create new content entries
- Metadata is stored separately from content for efficient queries
- Full version history is maintained for all documents
- Content is encrypted at rest and in transit
- Performance optimized for read operations (read:write ratio ~10:1)

## Component Diagram
[Include diagram here]

## Component Description
The Document Storage Service consists of the following subcomponents:

### Content Store
Responsible for storing the actual document content:
- Uses object storage (S3-compatible) for raw content
- Implements content-addressable storage using SHA-256 hashing
- Handles deduplication of identical content
- Manages encryption and decryption of content
- Implements tiered storage for hot/warm/cold access patterns

### Metadata Service
Manages document metadata and relationships:
- Uses PostgreSQL for structured metadata
- Implements flexible tagging and categorization
- Handles document relationships and references
- Manages access control information
- Provides efficient search and filtering capabilities

### Version Control Service
Manages document versioning:
- Tracks content changes over time
- Maintains full version history
- Implements branching and merging capabilities
- Provides diff generation between versions
- Manages version tags and annotations

### Search Indexer
Indexes document content for searching:
- Uses Elasticsearch for full-text indexing
- Handles multi-language content
- Implements near real-time indexing
- Provides relevance-based search capabilities
- Supports faceted search and filtering

## Interaction Patterns
- **Document Creation**: Client -> API Gateway -> Metadata Service -> Content Store -> Search Indexer
- **Document Retrieval**: Client -> API Gateway -> Metadata Service -> Content Store
- **Document Search**: Client -> API Gateway -> Search Service -> Metadata Service
- **Version Comparison**: Client -> API Gateway -> Version Control Service -> Content Store

## Data Flow Diagram
[Include diagram here]

## Technology Stack
- Object Storage: MinIO (dev/test), AWS S3 (production)
- Metadata Database: PostgreSQL 14+
- Search Index: Elasticsearch 8+
- API Layer: Node.js with Express
- Caching: Redis 6+
- Service Communication: gRPC
- Authentication: JWT-based with OAuth 2.0

## Constraints and Limitations
- Maximum document size: 1GB
- Maximum number of versions per document: Unlimited
- Storage capacity: Initially 10TB, expandable to 100TB
- Maximum document retrieval latency: 200ms (P95)
- Search indexing latency: <5 seconds for documents under 10MB

## Cross-cutting Concerns

### Security
- All content encrypted at rest (AES-256)
- All communication encrypted in transit (TLS 1.3)
- Fine-grained access control at document level
- Audit logging for all operations
- Compliance with data sovereignty requirements

### Performance
- Content delivery via CDN for frequent access
- Read replicas for metadata in high-load scenarios
- Caching strategy for recently accessed documents
- Bulk operations for batch processing
- Background processing for indexing and analysis

### Scalability
- Horizontal scaling for all components
- Sharding strategy for metadata database
- Multi-region deployment for global access
- Auto-scaling based on load metrics
- Rate limiting to prevent abuse

## Evolution Strategy
The Document Storage Service will evolve in the following phases:
1. **Phase 1 (Q2 2025)**: Basic document storage and retrieval with versioning
2. **Phase 2 (Q3 2025)**: Enhanced search capabilities and metadata management
3. **Phase 3 (Q4 2025)**: Collaborative editing integration and real-time updates
4. **Phase 4 (Q1 2026)**: Advanced analytics and ML-based document insights

## Cursor Implementation Directions
To implement this component:

### File Structure
```
src/services/document-storage/
├── content/
│   ├── content-store.js
│   ├── content-encryption.js
│   └── content-addressing.js
├── metadata/
│   ├── metadata-service.js
│   ├── schema.js
│   └── migrations/
├── versioning/
│   ├── version-control.js
│   ├── diff-generator.js
│   └── merge-service.js
├── search/
│   ├── indexer.js
│   ├── search-service.js
│   └── analyzers/
└── api/
    ├── routes.js
    ├── controllers.js
    └── validators.js
```

### Implementation Sequence
1. Start with content store implementation (basic storage and retrieval)
2. Implement metadata service with basic document properties
3. Add version control functionality
4. Integrate search indexing
5. Implement API layer
6. Add security features (encryption, access control)
7. Implement performance optimizations (caching, etc.)
8. Add advanced features (collaborative editing, etc.)

### Key Functions
- `storeContent(buffer, contentType)`: Stores raw content and returns contentId
- `retrieveContent(contentId)`: Retrieves content by ID
- `createDocument(metadata, contentId)`: Creates document linking metadata to content
- `updateDocument(documentId, metadata, contentId)`: Updates document with new metadata and/or content
- `getDocumentVersions(documentId)`: Retrieves version history for a document
- `compareVersions(documentId, versionA, versionB)`: Generates diff between versions

### Testing Approach
- Unit tests for each service and subcomponent
- Integration tests for service interactions
- Performance tests for throughput and latency
- Security tests for encryption and access control
- End-to-end tests for common user flows

### Related Cursor Rules
- @rule:js-coding-standards
- @rule:service-architecture-patterns
- @rule:api-design-guidelines
- @rule:security-implementation-standards

## Related Documentation
- [API Documentation](mdc:../../apis/document-api.md)
- [Data Architecture](mdc:../data-architecture/document-data-model.md)
- [Security Architecture](mdc:../../security/content-security.md)
- [Performance Requirements](mdc:../../testing/performance/document-performance-requirements.md)
```

## Validation Criteria
Technical documentation complies with these standards if it:
1. Follows all global documentation standards
2. Contains all required sections for its specific document type
3. Includes appropriate diagrams and visualizations
4. Uses consistent terminology and notation
5. Contains detailed implementation guidance
6. Includes proper code examples where applicable
7. Specifies security and performance considerations
8. Documents constraints and limitations
9. Includes comprehensive Cursor Implementation Directions
10. Properly cross-references related documentation

## Automation Capabilities
An AI agent can validate compliance with these standards by:
1. Checking for presence of required sections
2. Verifying that diagrams are present and referenced
3. Validating code examples for syntax and completeness
4. Checking for appropriate security and performance documentation
5. Verifying that Cursor Implementation Directions are comprehensive
6. Ensuring proper cross-referencing between technical documents
7. Validating technical terminology usage for consistency
8. Checking that technology versions are specified
9. Ensuring architecture principles are clearly articulated
10. Verifying that evolution strategy is documented
